---
layout:     post
header:     go-and-sockets
title:      Go & sockets
date:       2013-03-17
---

Передо мной была поставлена задача: необходимо написать модуль для сайта, чтобы тот отдавал данные пользователю в реальном времени. Сайт не для корпоратива, значит старые браузеры можно не поддерживать. Решение пало на использование WebSocket, т.к. это быстро и nginx начал поддерживать их проксирование.

По началу, как и многие кто «не шарит», я выбрал [Socket.IO](http://socket.io). Использовал его в одном из своих проектов, который так и не добрался до продакшна. Для общения между NodeJS и Rails использовал прокладку из Redis с его pub/sub. Все было хорошо, пока не прочел про фейлы Socket.IO ([1](https://groups.google.com/d/msg/ror2ru/0vPgXCYtC9Y/_UONIU53ypAJ), [2](https://groups.google.com/d/msg/ror2ru/0vPgXCYtC9Y/kznukvB0K50J)), как он жрет память и процессор, и моя прокладка подверглась критике, сказали, что это лишние миллисекунды.

И тогда пришлось искать замену, т.к. это решение не приемлемо для текущего проекта. Задача там [не тривиальая](https://groups.google.com/d/msg/ror2ru/nOioVkvGBtI/Is5xSi80Zr8J), нужно сделать отдачу контента пользователям по подписанным каналам, число которых эквивалентно числу пользовтелей, плюс пачка общих.

Сначала подумывал об Erlang, но я его совсем не знаю и времени на изучение мало. Он идеально подошел бы для этой задачи. Найм программиста не рассматривается вообще, денег у нас нет. Дальше по списку пошел язык Go, эдакий гибрид из Python и C, компилируемый и легкий в освоении, что являлось огромным плюсом в его выборе, а еще есть нативная поддержка TCP и Web сокетов.

На освоение Go «как корова, без доков писать не могу» ушло два вечера, чего мне вполне хватило. Сначала написал свое решение, страшно-криво, но оно работало. Все просто &mdash; рельса пишет в TCPSocket, Go его читает и отдает контент пользователю по WebSocket'у. Но решение было настолько страшным, что пришлось искать что-то готовое.

Так нашлелся набор инструментов [NSQ](https://github.com/bitly/nsq), который разрабатывают небезызвестные [bit.ly](https://bitly.com). С [производительностью все хорошо](https://github.com/bitly/nsq#performance), есть каналы из коробки и простейшая [обертка для Ruby](https://github.com/ClarityServices/ruby_nsq). Синтетические тесты показали себя очень хорошо, NSQ подходит для решения поставленной задачи, осталось написать только отдачу контента пользователям и простую авторизацию.

Когда все это сделаю &mdash; выложу наработки на github, авось пригодится кому. И в планах все таки выучить Erlang, говорят, отличная штука для подобных задач, где бушуют высокая нагрузка и бесконечный аптайм.
